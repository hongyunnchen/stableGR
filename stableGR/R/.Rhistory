library(devtools)
install.packages("roxygen")
install.packages("roxygen2")
q()
devtools::document()
devtools::document()
minESS <- mcmcse::minESS
?minESS
citation(mcmcse)
citation("mcmcse")
p <- 1
epsilon <- .05
delta <- .1
if(is.null(delta)){
Tee <- as.numeric(minESS(p, epsilon, alpha = alpha)) #min effective sample size
}
Tee
M <- m/((1-delta)^2 - 1)
minESS(p, eps = epsilon, ess = M)
m <- 5
M <- m/((1-delta)^2 - 1)
minESS(p, eps = epsilon, ess = M)
M <- m/((1+delta)^2 - 1)
minESS(p, eps = epsilon, ess = M)
choosepsrf <- function(p, epsilon, delta = NULL, m, alpha=.05){
if(is.null(delta)){
Tee <- as.numeric(minESS(p, epsilon, alpha = alpha)) #min effective sample size
}
if(is.null(delta) == FALSE){
M <- m/((1+delta)^2 - 1)
epsilon <- minESS(p, eps = epsilon, ess = M)
}
del <- sqrt(1 + m/Tee) - 1
arr <- 1 + del
list(psrf = arr, epsilon = epsilon, delta = del)
}
choosepsrf(1, delta = .1, m = 5, alpha = .05)
choosepsrf <- function(p, epsilon = .05, delta = NULL, m, alpha=.05){
if(is.null(delta)){
Tee <- as.numeric(minESS(p, epsilon, alpha = alpha)) #min effective sample size
}
if(is.null(delta) == FALSE){
Tee <- M <- m/((1+delta)^2 - 1)
epsilon <- minESS(p, eps = epsilon, ess = M)
}
del <- sqrt(1 + m/Tee) - 1
arr <- 1 + del
list(psrf = arr, epsilon = epsilon, delta = del)
}
choosepsrf(1, delta = .1, m = 5, alpha = .05)
library(mcmcdiag)
p <- 1
alpha <- .05
m <- 5
choosepsrf(p, delta = .1, m = m, alpha = alpha)
choosepsrf(p, epsilon = .05, m = m, alpha = alpha)
out2a <- choosepsrf(p, epsilon = .05, m = m, alpha = alpha)
Tee <- M <- m/((1+delta)^2 - 1)
epsilon <- as.numeric(minESS(p, eps = epsilon, ess = M))
del <- sqrt(1 + m/Tee) - 1
arr <- 1 + del
out2b <- list(psrf = arr, epsilon = epsilon, delta = del)
all.equal(out2a, out2b)
epsilon <- .05
out2a <- choosepsrf(p, epsilon = epsilon, m = m, alpha = alpha)
Tee <- M <- m/((1+delta)^2 - 1)
epsilon <- as.numeric(minESS(p, eps = epsilon, ess = M))
del <- sqrt(1 + m/Tee) - 1
arr <- 1 + del
out2b <- list(psrf = arr, epsilon = epsilon, delta = del)
all.equal(out2a, out2b)
out2a
out2b
delta <- .01
out2a <- choosepsrf(p, delta = delta, m = m, alpha = alpha)
Tee <- M <- m/((1+delta)^2 - 1)
epsilon <- as.numeric(minESS(p, eps = epsilon, ess = M))
del <- sqrt(1 + m/Tee) - 1
arr <- 1 + del
out2b <- list(psrf = arr, epsilon = epsilon, delta = del)
all.equal(out2a, out2b)
out2a
out2b
as.numeric(minESS(p, eps = epsilon, ess = M))
epsilon <- as.numeric(minESS(p, eps = epsilon, ess = M))
epsilon
del <- sqrt(1 + m/Tee) - 1
del
out2b <- list(psrf = arr, epsilon = epsilon, delta = del)
out2b
out2a
epsilon <- .05
choosepsrf(p, epsilon = epsilon, m = m, alpha = alpha)
out1a <- choosepsrf(p, epsilon = epsilon, m = m, alpha = alpha)
Tee <- as.numeric(minESS(p, epsilon, alpha = alpha)) #min effective sample size
del <- sqrt(1 + m/Tee) - 1
arr <- 1 + del
list(psrf = arr, epsilon = epsilon, delta = del)
out1b <- list(psrf = arr, epsilon = epsilon, delta = del)
out1a
out1b
all.equal(out1a, out1b)
############################################################
# Bayesian Logistic Regression with Titanic Data
############################################################
############################################################
############################################################
# Getting started.
# install.packages(titanic)
library(MCMCpack)
library(titanic)
data(titanic_test)
library(mcmcdiag)
# Taking the relevant parameters in the data.
# Leaving out Embarked since not important
titanic_sub <- titanic_train[ ,c(2,3,5,6,7,8,10,12)]
titanic_sub$Pclass <- as.factor(titanic_sub$Pclass)
titanic_sub$Sex <- as.factor(titanic_sub$Sex)
titanic_sub$Embarked <- as.factor(titanic_sub$Embarked)
# Original data has missing age
# colSums(is.na(titanic_sub))
# remove missing data
titanic_comp <- titanic_sub[complete.cases(titanic_sub), ]
# Embark should be only 3 levels, but there is a 4th, which is due to data entry error
# which(titanic_comp$Embarked == "")
titanic_comp <- titanic_comp[-which(titanic_comp$Embarked == ""),  ]
# Titan_chain runs the MCMC for a given Monte Carlo sample size.
# MCMClogit function requires a seed set. So pass a random seed to it.
titan_chain <- function(seed, N, beta.start = NA)
{
chain <- MCMClogit(formula = Survived~ 1 + . , data = titanic_comp, beta.start = beta.start, verbose = 0,seed = seed, burnin = 0, mcmc = N, thin = 1, B0 = 1/1e2, tune = .8)
return(chain)
}
# Try things out
seed <- 1234
N <- 1000
out <- titan_chain(seed, N)
summary(out)
confidence <- .95
blather <- TRUE
multivariate <- TRUE
transform <- autoburnin <- FALSE
mapping <- "determinant"
method <- "lug"
i <- 1
dosplit <- FALSE
confidence <- .95
blather <- TRUE
multivariate <- TRUE
transform <- autoburnin <- FALSE
mapping <- "determinant"
method <- "lug"
i <- 1
dosplit <- FALSE
x <- out
gettau <- mcmcdiag:::gettau
getT <- mcmcdiag:::getT
adjust_matrix <- mcmcdiag:::adjust_matrix
x <- as.mcmc.list(x)
if (autoburnin && start(x) < end(x)/2)
x <- window(x, start = end(x)/2 + 1)
Niter <- niter(x)  # number of iterations per chains. We also call this n.
Nchain <- nchain(x) # number of chains. We also call this m.
Nvar <- nvar(x) # number of variables
xnames <- varnames(x)
if (transform)
x <- gelman.transform(x)
x <- lapply(x, as.matrix)
xbar <- matrix(sapply(x, apply, 2, mean, simplify = TRUE),nrow = Nvar, ncol = Nchain)
muhat <- apply(xbar, 1, mean)
Si2 <- array(sapply(x, var, simplify = TRUE), dim = c(Nvar, Nvar, Nchain))
W <- apply(Si2, c(1, 2), mean) # Average the vcov matrices across chains. #aka S
Ssq <- diag(W) # Isolate the variances, throw away covariances.
s2 <- matrix(apply(Si2, 3, diag), nrow = Nvar, ncol = Nchain)
tau2i <- matrix(sapply(x, gettau, method = method)*Niter,  ncol = Nchain) # For each chain
tau2 <- apply(tau2i, 1, mean)  # Average over the chains
sigsq <- (Niter - 1) * Ssq/Niter + tau2 / Niter
arrr <- sigsq / Ssq
psrf <- sqrt(arrr)
blatherout <- blather
if(blather){
blatherout <- list(muhat = muhat, method = method, Niter = Niter, Nchain = Nchain, Nvar = Nvar,
tausq = tau2, ssq <- s2, sigsq = sigsq) }
mpsrf <- multivariate
Nvar > 1
multivariate
multivariate && Nvar > 1
Ti <- lapply(x, getT, method = method)  # For each chain
Tee <- matrix(Reduce("+", Ti)  / Nchain, nrow = Nvar)
firstpiece <- (Niter-1)/Niter
secondpiece <- Niter
mango <- qr.solve(W, Tee) #S^{-1}T
eigs <- eigen(mango, symmetric = TRUE, only.values = TRUE)$values
thirdpiecedet <- exp(mean(log(eigs)))
thirdpiecemax <- max(eigs)
eigs
log(eigs)
mango <- solve(W, Tee) #S^{-1}T
eigs <- eigen(mango, symmetric = TRUE, only.values = TRUE)$values
thirdpiecedet <- exp(mean(log(eigs)))
mango
Tee
W
is.symmetric(Tee)
det(mango)
eigs
thirdpiecedet <- prod(eigs^(1/Nvar))
thirdpiecedet
eigs^(1/Nvar)
eigs
prod(eigs)
(prod(eigs)^(1/Nvar)
)
(prod(eigs))^(1/Nvar)
det(mango)
det
thirdpiecedet <- (prod(eigs))^(1/Nvar)
thirdpiecemax <- max(eigs)
mpsrfdet <- sqrt(firstpiece + secondpiece*thirdpiecedet)
mpsrfmax <- sqrt(firstpiece + secondpiece*thirdpiecemax)
if(mapping == "determinant"){ mpsrf <- mpsrfdet
if(mapping == "determinant"){ mpsrf <- mpsrfdet
}else{ mpsrf <- mpsrfmax
if(mapping == "determinant"){ mpsrf <- mpsrfdet
}else{ mpsrf <- mpsrfmax
}
if(blather){
blatherout$S <- W
blatherout$Tee <- Tee
blatherout$eigenvalues <- eigs
blatherout$mpsrfdet <- mpsrfdet
blatherout$mpsrfmax <- mpsrfmax
}
if(multivariate && Nvar > 1){
Ti <- lapply(x, getT, method = method)  # For each chain
Tee <- matrix(Reduce("+", Ti)  / Nchain, nrow = Nvar)
firstpiece <- (Niter-1)/Niter
secondpiece <- Niter
mango <- solve(W, Tee) #S^{-1}T
eigs <- eigen(mango, symmetric = TRUE, only.values = TRUE)$values
thirdpiecedet <- (prod(eigs))^(1/Nvar)
thirdpiecemax <- max(eigs)
mpsrfdet <- sqrt(firstpiece + secondpiece*thirdpiecedet)
mpsrfmax <- sqrt(firstpiece + secondpiece*thirdpiecemax)
if(mapping == "determinant"){ mpsrf <- mpsrfdet
}else{ mpsrf <- mpsrfmax
}
if(blather){
blatherout$S <- W
blatherout$Tee <- Tee
blatherout$eigenvalues <- eigs
blatherout$mpsrfdet <- mpsrfdet
blatherout$mpsrfmax <- mpsrfmax
}
}
list(psrf = psrf, mpsrf = mpsrf, means = muhat, blather = blatherout)
gelman.bm <-
function (x, confidence = 0.95, transform = FALSE,
mapping = "determinant", autoburnin = FALSE,
multivariate = TRUE, method = "lug", blather = FALSE)
{
x <- as.mcmc.list(x)
if (autoburnin && start(x) < end(x)/2)
x <- window(x, start = end(x)/2 + 1)
# Define some notation.
Niter <- niter(x)  # number of iterations per chains. We also call this n.
Nchain <- nchain(x) # number of chains. We also call this m.
Nvar <- nvar(x) # number of variables
xnames <- varnames(x)
# Transform to logit or log if asked and if applicable.
if (transform)
x <- gelman.transform(x)
# Since x is a list of markov chains, turn each into matrix.
x <- lapply(x, as.matrix)
# First, calculate sample means.
# Calculate column means for each chain.
xbar <- matrix(sapply(x, apply, 2, mean, simplify = TRUE),nrow = Nvar, ncol = Nchain)
# Average the means across chains
muhat <- apply(xbar, 1, mean)
# Second, calculate overall sample variance for each variable.
# Calculate vcov matrix for variables in each chain. List length = nchain.
Si2 <- array(sapply(x, var, simplify = TRUE), dim = c(Nvar, Nvar, Nchain))
W <- apply(Si2, c(1, 2), mean) # Average the vcov matrices across chains. #aka S
Ssq <- diag(W) # Isolate the variances, throw away covariances.
# For each chain, find sample variance for each variable.
s2 <- matrix(apply(Si2, 3, diag), nrow = Nvar, ncol = Nchain)
# Third, calculate tau^2 and its variance for each variable.
# This replaces the GR b.
# Sample variance of the sample means (between chain vars) calculated using batch means.
tau2i <- matrix(sapply(x, gettau, method = method)*Niter,  ncol = Nchain) # For each chain
tau2 <- apply(tau2i, 1, mean)  # Average over the chains
# Calculate the estimate of sigma^2.
sigsq <- (Niter - 1) * Ssq/Niter + tau2 / Niter
arrr <- sigsq / Ssq
psrf <- sqrt(arrr)
blatherout <- blather
if(blather){
blatherout <- list(muhat = muhat, method = method, Niter = Niter, Nchain = Nchain, Nvar = Nvar,
tausq = tau2, ssq <- s2, sigsq = sigsq) }
mpsrf <- multivariate
if(multivariate && Nvar > 1){
Ti <- lapply(x, getT, method = method)  # For each chain
Tee <- matrix(Reduce("+", Ti)  / Nchain, nrow = Nvar)
firstpiece <- (Niter-1)/Niter
secondpiece <- Niter
mango <- solve(W, Tee) #S^{-1}T
eigs <- eigen(mango, symmetric = TRUE, only.values = TRUE)$values
thirdpiecedet <- (prod(eigs))^(1/Nvar)
thirdpiecemax <- max(eigs)
mpsrfdet <- sqrt(firstpiece + secondpiece*thirdpiecedet)
mpsrfmax <- sqrt(firstpiece + secondpiece*thirdpiecemax)
if(mapping == "determinant"){ mpsrf <- mpsrfdet
}else{ mpsrf <- mpsrfmax
}
if(blather){
blatherout$S <- W
blatherout$Tee <- Tee
blatherout$eigenvalues <- eigs
blatherout$mpsrfdet <- mpsrfdet
blatherout$mpsrfmax <- mpsrfmax
}
}
list(psrf = psrf, mpsrf = mpsrf, means = muhat, blather = blatherout)
}
mpsrf
mpsrfdet
mpsrfmax
secondpiece
secondpiece <- 1/Niter
mango <- solve(W, Tee) #S^{-1}T
eigs <- eigen(mango, symmetric = TRUE, only.values = TRUE)$values
thirdpiecedet <- (prod(eigs))^(1/Nvar)
thirdpiecemax <- max(eigs)
mpsrfdet <- sqrt(firstpiece + secondpiece*thirdpiecedet)
mpsrfmax <- sqrt(firstpiece + secondpiece*thirdpiecemax)
if(mapping == "determinant"){ mpsrf <- mpsrfdet
if(mapping == "determinant"){ mpsrf <- mpsrfdet
}else{ mpsrf <- mpsrfmax
if(mapping == "determinant"){ mpsrf <- mpsrfdet
}else{ mpsrf <- mpsrfmax
}
if(blather){
blatherout$S <- W
blatherout$Tee <- Tee
blatherout$eigenvalues <- eigs
blatherout$mpsrfdet <- mpsrfdet
blatherout$mpsrfmax <- mpsrfmax
}
if(multivariate && Nvar > 1){
Ti <- lapply(x, getT, method = method)  # For each chain
Tee <- matrix(Reduce("+", Ti)  / Nchain, nrow = Nvar)
firstpiece <- (Niter-1)/Niter
secondpiece <- 1/Niter
mango <- solve(W, Tee) #S^{-1}T
eigs <- eigen(mango, symmetric = TRUE, only.values = TRUE)$values
thirdpiecedet <- (prod(eigs))^(1/Nvar)
thirdpiecemax <- max(eigs)
mpsrfdet <- sqrt(firstpiece + secondpiece*thirdpiecedet)
mpsrfmax <- sqrt(firstpiece + secondpiece*thirdpiecemax)
if(mapping == "determinant"){ mpsrf <- mpsrfdet
}else{ mpsrf <- mpsrfmax
}
if(blather){
blatherout$S <- W
blatherout$Tee <- Tee
blatherout$eigenvalues <- eigs
blatherout$mpsrfdet <- mpsrfdet
blatherout$mpsrfmax <- mpsrfmax
}
}
list(psrf = psrf, mpsrf = mpsrf, means = muhat, blather = blatherout)
mpsrf <- multivariate
if(multivariate && Nvar > 1){
Ti <- lapply(x, getT, method = method)  # For each chain
Tee <- matrix(Reduce("+", Ti)  / Nchain, nrow = Nvar)
firstpiece <- (Niter-1)/Niter
secondpiece <- 1/Niter
mango <- solve(W, Tee) #S^{-1}T
eigs <- eigen(mango, symmetric = TRUE, only.values = TRUE)$values
thirdpiecedet <- (prod(eigs))^(1/Nvar)
thirdpiecemax <- max(eigs)
mpsrfdet <- sqrt(firstpiece + secondpiece*thirdpiecedet)
mpsrfmax <- sqrt(firstpiece + secondpiece*thirdpiecemax)
if(mapping == "determinant"){ mpsrf <- mpsrfdet
}else{ mpsrf <- mpsrfmax
}
if(blather){
blatherout$S <- W
blatherout$Tee <- Tee
blatherout$eigenvalues <- eigs
blatherout$mpsrfdet <- mpsrfdet
blatherout$mpsrfmax <- mpsrfmax
}
}
list(psrf = psrf, mpsrf = mpsrf, means = muhat, blather = blatherout)
set.seed(10)
library(mvtnorm)
library(mcmcse)
library(coda)
library(mcmcdiag)
################
# Start by making a few chains to work with
# Details on the chain construction
p <- 5
N <- 10000
tail.ind <- floor(N*.80):N
foo <- matrix(.50, nrow=p, ncol=p)
sigma <- foo^(abs(col(foo)-row(foo)))
mu <- sample(10:20, p)
mu2 <- mu[p]
# Create the chains
mvn_gibbs <- mcmcdiag:::mvn_gibbs
out.gibbs1 <- mvn_gibbs(N = N, mu = mu, sigma = sigma, p = p)
out.gibbs2 <- mvn_gibbs(N = N, mu = mu, sigma = sigma, p = p)
# Convert to MCMC objects
out1 <- mcmc(out.gibbs1)
out2 <- mcmc(out.gibbs2)
obj <- mcmc.list(out1, out2)
################
# Perform unit test using the two chains in obj
withfun <- gelman.bm(obj)$mpsrf
# Calculate Tmat for each chain
Tmat1 <- mcse.multi(out1, method = "lug")$cov
Tmat2 <- mcse.multi(out2, method = "lug")$cov
That <- .5*(Tmat1 + Tmat2) #good
#Calc Smat
cov1 <- var(out1)
cov2 <- var(out2)
Smat <- .5*(cov1 + cov2) #good
#calculate determinants
Teigen <- eigen(That)$values
Seigen <- eigen(Smat)$values
detT <- (prod(Teigen))
detS <- (prod(Seigen))
detratio <- detT/detS #good
Nchain <- nchain(obj)
all.equal(2, Nchain)
rhat <- (N-1)/N + (Nchain +1)/(Nchain * N) *(detratio)^(1/p)
byhand <- sqrt(rhat)
all.equal(byhand, withfun)
################ ################ ################
# Perform unit test using a SINGLE chain (just in case)
onechain <- mcmc.list(out1)
withfun <- gelman.bm(onechain)$mpsrf
#calculate determinants
Teigen <- eigen(Tmat1)$values
Seigen <- eigen(cov1)$values
detT <- (prod(Teigen))
detS <- (prod(Seigen))
detratio <- detT/detS #good
Nchain <- nchain(onechain)
all.equal(1, Nchain)
rhat <- (N-1)/N + 1/(N) *(detratio)^(1/p)
byhand <- sqrt(rhat)
all.equal(byhand, withfun)
byhand
withfun
library(glmm)
clust <- makeCluster(4)
dating <- read.csv(file="Speed Dating Data.csv",header=TRUE, sep=",")
dating<-dating[complete.cases(dating$field_cd,dating$iid,dating$pid,dating$gender,dating$race,dating$samerace),]
dating <-subset(dating, wave != 5)
#new variables
#dating$age_diff <- dating$age-dating$age_o
#dating$self_rate <- ave(dating$attr5_1,dating$sinc5_1,dating$intel5_1,dating$fun5_1,dating$amb5_1)
#naming variables
dating$field_cat <- ifelse(dating$field_cd==1 | dating$field_cd==8 |dating$field_cd==11 |dating$field_cd==17, "Professional Degree", ifelse(dating$field_cd==2 | dating$field_cd==4 |dating$field_cd==5 |dating$field_cd==10, "Science and Engineering",ifelse(dating$field_cd==3 | dating$field_cd==13 |dating$field_cd==9, " Social Sciences", ifelse(dating$field_cd==6 | dating$field_cd==7 |dating$field_cd==14 |dating$field_cd==15 |dating$field_cd==16, "Humanities and Art",ifelse(dating$field_cd==12 | dating$field_cd==18,"Other","")))))
dating$race_name <- as.factor(ifelse(dating$race==1,"Black",ifelse(dating$race==2,"European",ifelse(dating$race==3,"Latino",ifelse(dating$race==4,"Asian",ifelse(dating$race==5,"Native Americans",ifelse(dating$race==6,"Other","")))))))
#formatting variables
dating$iid <- as.factor(dating$iid)
dating$pid <- as.factor(dating$pid)
dating$gender <- as.factor(dating$gender)
dating$field_cat <- as.factor(dating$field_cat)
dating$samerace <- as.factor(dating$samerace)
###########################################
# EDA
dim(dating)
summary(dating$field_cat)
summary(dating$samerace)
summary(dating$gender)
length(unique(dating$pid))
length(unique(dating$iid))
summary(dating$race_name)
?glmm
detectCores()
