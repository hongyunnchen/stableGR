top <- (N-1) + ((detratio)^(1/p))
byhand <- sqrt(top/N)
all.equal(That, blather$Tee)
set.seed(10)
library(mvtnorm)
library(mcmcse)
library(coda)
library(mcmcdiag)
p <- 5
N <- 10000
tail.ind <- floor(N*.80):N
foo <- matrix(.50, nrow=p, ncol=p)
sigma <- foo^(abs(col(foo)-row(foo)))
mu <- sample(10:20, p)
mu2 <- mu[p]
mvn_gibbs <- mcmcdiag:::mvn_gibbs
out.gibbs1 <- mvn_gibbs(N = N, mu = mu, sigma = sigma, p = p)
out.gibbs2 <- mvn_gibbs(N = N, mu = mu, sigma = sigma, p = p)
out1 <- mcmc(out.gibbs1)
out2 <- mcmc(out.gibbs2)
obj <- mcmc.list(out1, out2)
withfun <- gelman.bm(obj, mapping = "maxeigen")$mpsrf
Tmat1 <- mcse.multi(out1, method = "lug")$cov
Tmat2 <- mcse.multi(out2, method = "lug")$cov
That <- .5*(Tmat1 + Tmat2) #good
cov1 <- var(out1)
cov2 <- var(out2)
Smat <- .5*(cov1 + cov2) #good
Sinv <- qr.solve(Smat)
thingy <- Sinv %*% That
maxeigen <- max(eigen(thingy)$values)
Nchain <- nchain(obj)
outwithfun <- gelman.bm(obj, mapping = "maxeigen", blather = TRUE)
withfun <- outwithfun$mpsrf
Tmat1 <- mcse.multi(out1, method = "lug")$cov
Tmat2 <- mcse.multi(out2, method = "lug")$cov
That <- .5*(Tmat1 + Tmat2) #good
cov1 <- var(out1)
cov2 <- var(out2)
Smat <- .5*(cov1 + cov2) #good
Sinv <- qr.solve(Smat)
thingy <- Sinv %*% That
maxeigen <- max(eigen(thingy)$values)
blather <- outwithfun$blather
blather
all.equal(maxeigen, max(blather$eigenvalues))
Nchain <- nchain(obj)
all.equal(2, Nchain)
rhat <- (N-1)/N +  maxeigen/N
byhand <- sqrt(rhat)
all.equal(byhand, withfun)
set.seed(10)
library(mvtnorm)
library(mcmcse)
library(coda)
library(mcmcdiag)
################
# Start by making a few chains to work with
# Details on the chain construction
p <- 5
N <- 10000
tail.ind <- floor(N*.80):N
foo <- matrix(.50, nrow=p, ncol=p)
sigma <- foo^(abs(col(foo)-row(foo)))
mu <- sample(10:20, p)
mu2 <- mu[p]
# Create the chains
mvn_gibbs <- mcmcdiag:::mvn_gibbs
out.gibbs1 <- mvn_gibbs(N = N, mu = mu, sigma = sigma, p = p)
out.gibbs2 <- mvn_gibbs(N = N, mu = mu, sigma = sigma, p = p)
# Convert to MCMC objects
out1 <- mcmc(out.gibbs1)
out2 <- mcmc(out.gibbs2)
obj <- mcmc.list(out1, out2)
################
# Perform unit test using the two chains in obj
withfun <- gelman.bm(obj, mapping = "maxeigen")$mpsrf
# Calculate Tmat for each chain
Tmat1 <- mcse.multi(out1, method = "lug")$cov
Tmat2 <- mcse.multi(out2, method = "lug")$cov
That <- .5*(Tmat1 + Tmat2) #good
#Calc Smat
cov1 <- var(out1)
cov2 <- var(out2)
Smat <- .5*(cov1 + cov2) #good
Sinv <- qr.solve(Smat)
thingy <- Sinv %*% That
maxeigen <- max(eigen(thingy)$values)
Nchain <- nchain(obj)
all.equal(2, Nchain)
rhat <- (N-1)/N +  maxeigen/N
byhand <- sqrt(rhat)
all.equal(byhand, withfun)
rm(list = ls())
library(MCMCpack)
library(titanic)
data(titanic_test)
library(mcmcdiag)
?gelman.bm
titanic_sub <- titanic_train[ ,c(2,3,5,6,7,8,10,12)]
titanic_sub$Pclass <- as.factor(titanic_sub$Pclass)
titanic_sub$Sex <- as.factor(titanic_sub$Sex)
titanic_sub$Embarked <- as.factor(titanic_sub$Embarked)
titanic_comp <- titanic_sub[complete.cases(titanic_sub), ]
titanic_comp <- titanic_comp[-which(titanic_comp$Embarked == ""),  ]
titan_chain <- function(seed, N, beta.start = NA)
{
chain <- MCMClogit(formula = Survived~ 1 + . , data = titanic_comp, beta.start = beta.start, verbose = 0,seed = seed, burnin = 0, mcmc = N, thin = 1, B0 = 1/1e2, tune = .8)
return(chain)
}
seed <- 1234
N <- 1000
out <- titan_chain(seed, N)
m <- 5
p <- ncol(out)
epsilon <- .1
Rhats <- c(1.1, choosepsrf(1, epsilon = epsilon, m = m, alpha = .05)$psrf)
foo <- glm(Survived ~ 1 + . , data = titanic_comp, family = binomial(link = logit))
MLEs <- coef(foo)
all.equal(names(coef(foo)), colnames(out)) # should be TRUE
SEs <- sqrt(diag(summary(foo)$cov.scaled))
multiplier <- c(-3, -2, 0, 2, 3) #for overdispersion
seeds <- 1:5 #a seed for each starting point, for now
N <- 1e5
for(i in 1:5){ #for each of the m=5 chains
startpts <- MLEs + multiplier[i] * SEs #calc the start point
result <- titan_chain(seed = seeds[i], N = N, beta.start = startpts)
}
seeds
i <- 1
startpts <- MLEs + multiplier[i] * SEs #calc the start point
chainlist <- NULL
chainlist[[i]]  <- titan_chain(seed = seeds[i], N = N, beta.start = startpts)
chainlist <- NULL
for(i in 1:5){ #for each of the m=5 chains
startpts <- MLEs + multiplier[i] * SEs #calc the start point
chainlist[[i]]  <- titan_chain(seed = seeds[i], N = N, beta.start = startpts)
}
obj <- mcmc.list(chainlist)
method <- "lug"
out<- gelman.bm(obj, method = method, blather = TRUE)
out$psrf
out$mpsrf
Rhats
chainlength
N
nloop <- 100
calcfreq <- N*nloop
calcfreq
calcfreq <- N/nloop
calcfreq
N
N*calcfreq
nloop*calcfreq
colNames <- c("chainlength", "GRpsrf", "ourpsrf")
estimates <- matrix(nrow = nloop, ncol = length(colNames))
colnames(estimates) <- colNames
head(estiamtes)
head(estimates)
i <- 1
thismuch <- i*calcfreq
head(chainlist[[1]])
minichain <- lapply(chainlist, function(x, thismuch) mcmc(x[1:thismuch,]), thismuch = thismuch)
summary(minichain)
obj <- mcmc.list(minichain)
summary(obj)
thismuch
out <- gelman.bm(obj, method = method, blather = TRUE)
estimates[i,1] <- thismuch
names(out)
out$blather
estimates[i,5] <- out$blather$mpsrfmax
colNames <- c("chainlength", "mpsrfMAX", "mpsrfDET")
colnames(estimates) <- colNames
out <- gelman.bm(obj, method = method, blather = TRUE)
estimates[i,1] <- thismuch
estimates[i,2] <- out$blather$mpsrfmax
estimates[i,3] <- out$blather$mpsrfdet
names(out)
length(out$means)
startpts
estimates <- matrix(nrow = nloop, ncol = length(colNames)+length(startpts))
colnames(estimates) <- colNames
colnames(estimates[1:3]) <- colNames
colnames(estimates)[1:3] <- colNames
names(startpts)
colNames <- c(c("chainlength", "mpsrfMAX", "mpsrfDET"), names(startpts))
colNames
estimates <- matrix(nrow = nloop, ncol = length(colNames))
colnames(estimates)<- colNames
i <- 1
thismuch <- i*calcfreq
minichain <- lapply(chainlist, function(x, thismuch) mcmc(x[1:thismuch,]), thismuch = thismuch)
# convert the list to an MCMC list
obj <- mcmc.list(minichain)
# Calculate values and store them
out <- gelman.bm(obj, method = method, blather = TRUE)
estimates[i,1] <- thismuch
estimates[i,2] <- out$blather$mpsrfmax
estimates[i,3] <- out$blather$mpsrfdet
ncol(estimates)
estimates[i, 4:ncol(estimates)] <- out$means
estimates[1,]
calcfreq
for(i in 1:nloop){
# Take first part of each chain, make into item of class mcmc, put into list
thismuch <- i*calcfreq
minichain <- lapply(chainlist, function(x, thismuch) mcmc(x[1:thismuch,]), thismuch = thismuch)
# convert the list to an MCMC list
obj <- mcmc.list(minichain)
# Calculate values and store them
out <- gelman.bm(obj, method = method, blather = TRUE)
estimates[i,1] <- thismuch
estimates[i,2] <- out$blather$mpsrfmax
estimates[i,3] <- out$blather$mpsrfdet
estimates[i, 4:ncol(estimates)] <- out$means
}
estimates[1:10,2:3]
nconv <- c(-1, -1)
Rhats
min(which(estimates[,2])<Rhats)
min((estimates[,2])<Rhats)
estimates[,2])<Rhats
estimates[,2]<Rhats
which(estimates[,2]<Rhats)
nconv <- matrix(rep(-1,4), nrow = 2)
nconv
rownames(nconv) <- Rhats
nconv
i <- j <- 1
j+1
estimates[,j+1]
estimates[,2]
min(which(estimates[,j+1]<Rhats[i]))
names(estimates)
head(estimates)
estimates <- data.frame(estimates)
names(estimates)
nconv <- estimates[thisone, chainlength]
nconv <- estimates$chainlength[thisone]
thisone <- min(which(estimates[,j+1]<Rhats[i]))
nconv <- estimates$chainlength[thisone]
nconv
nconv <- matrix(rep(-1,4), nrow = 2)
rownames(nconv) <- Rhats
colnames(nconv) <- c("MaxEigen", "Det")
thisone <- min(which(estimates[,j+1]<Rhats[i]))
nconv[i,j] <- estimates$chainlength[thisone]
nconv
min(which(estimates[,3]< Rhats[1]))
head(estimates)
Rhats[1]
min(which(estimates[,3]< Rhats[2]))
min(which(estimates[,2]< Rhats[2]))
for(i in 1:nrow(nconv)){
for(j in 1:ncol(nconv)){
thisone <- min(which(estimates[,j+1]<Rhats[i]))
nconv[i,j] <- estimates$chainlength[thisone]
}
}
nconv
names(estimates)
colnames(estimates)[2:3]
colnames(nconv) <- colnames(estimates)[2:3]
for(i in 1:nrow(nconv)){
for(j in 1:ncol(nconv)){
thisone <- min(which(estimates[,j+1]<Rhats[i]))
nconv[i,j] <- estimates$chainlength[thisone]
}
}
nconv
i <- j <- 1
thisone <- min(which(estimates[,j+1]<Rhats[i]))
nconv[i,j] <- estimates$chainlength[thisone]
mod <- estimates[thisone, 4:14]
thisone
colnames(estimates)
dim(estimates)
mod <- estimates[thisone, 4:ncol(estimates)]
i <- 1
colNames <- c(c("chainlength", "mpsrfMAX", "mpsrfDET"), names(startpts), c("CIlower", "CIupper"))
estimates <- matrix(nrow = nloop, ncol = length(colNames))
colnames(estimates)<- colNames
thismuch <- i*calcfreq
minichain <- lapply(chainlist, function(x, thismuch) mcmc(x[1:thismuch,]), thismuch = thismuch)
# convert the list to an MCMC list
obj <- mcmc.list(minichain)
out <- gelman.bm(obj, method = method, blather = TRUE)
estimates[i,1] <- thismuch
estimates[i,2] <- out$blather$mpsrfmax
estimates[i,3] <- out$blather$mpsrfdet
estimates[i, 4:13] <- out$means
altogether <- Reduce(minichain, cbind)
?Reduce
altogether <- Reduce(cbind, minichain)
dim(altogether)
altogether <- Reduce(rbind, minichain)
colNames <- c(c("chainlength", "mpsrfMAX", "mpsrfDET"), names(startpts))
estimates <- matrix(nrow = nloop, ncol = length(colNames))
colnames(estimates)<- colNames
CIlower <- CIupper <- matrix(nrow=nloop, ncol = length(names(startpts)))
dim(CIlower)
alpha <- .05
j <-1
altogether <- Reduce(rbind, minichain)
quantile(altogether[ ,j], alpha/2)
quantile(altogether[,1], .025)
quantile(altogether, .025)
1-alpha/2
CIupper[i,j] <- quantile(altogether[ ,j], 1-alpha/2)
CIupper[i,j]
CIupper[1,1]
CIlower[1,1]
CIlower[i,j] <- quantile(altogether[ ,j], alpha/2)
CIlower[1,1]
for(j in 1:ncol(minichain)){
CIlower[i,j] <- quantile(altogether[ ,j], alpha/2)
CIupper[i,j] <- quantile(altogether[ ,j], 1-alpha/2)
}
for(j in 1:ncol(altogether)){
CIlower[i,j] <- quantile(altogether[ ,j], alpha/2)
CIupper[i,j] <- quantile(altogether[ ,j], 1-alpha/2)
}
CIlower[1,]
CIupper[1,]
